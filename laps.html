<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Race Position by Lap (JSON selectable)</title>
  <style>
    #chart {
      width: 800px;  /* 初期値。JS で上書きされる */
      height: 500px; /* 初期値。JS で上書きされる */
    }
    body {
      font-family: system-ui, sans-serif;
      font-size: 14px;
      margin: 0;
    }
    #status {
      margin: 8px 12px;
      color: #555;
    }
  </style>
  <!-- ECharts CDN -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <div id="status">JSON を読み込んでいます...</div>
  <div id="chart"></div>

  <script>
    // ===== ここから JS =====

    const statusEl = document.getElementById("status");
    const chartDom = document.getElementById("chart");
    const chart = echarts.init(chartDom);

    // タッチデバイス or 小さい画面ならモバイルっぽい扱い（点サイズなどに利用）
    const isMobileLike =
      (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) ||
      ((window.innerWidth || document.documentElement.clientWidth) < 768);

    // --- 画面サイズに応じてチャート領域を調整 ---
    function updateChartSize() {
      const w = window.innerWidth || document.documentElement.clientWidth;
      const h = window.innerHeight || document.documentElement.clientHeight;

      // 横幅
      if (w >= 900) {
        // 900px 以上ならウィンドウ幅いっぱい
        chartDom.style.width = w + "px";
      } else {
        // 900px 未満なら 800px 固定
        chartDom.style.width = "800px";
      }

      // 高さ
      let chartHeight;
      if (h < 600) {
        // 高さが 600px 未満なら 500px 固定
        chartHeight = 500;
      } else {
        // 600px 以上ならウィンドウ高さからステータス分を引く
        chartHeight = h - 80;
        if (chartHeight < 500) chartHeight = 500; // 一応下限
      }
      chartDom.style.height = chartHeight + "px";

      chart.resize();
    }

    // 最初とリサイズ時に反映
    updateChartSize();
    window.addEventListener("resize", updateChartSize);

    // グローバル状態
    let laps = [];
    let nos = [];
    let noLapMap = new Map();        // key: `${no}-${lap}` -> rank
    let noLapDetailMap = new Map();  // key: `${no}-${lap}` -> { rank, lapTime, time, elapsed }
    let maxRank = 1;
    const highlightedNos = new Set();
    let handlersInitialized = false; // イベントハンドラ多重登録防止
    let startTimeNs = null;          // Start.Time (ns)

    // PC 用: 直近ホバーしている点
    let lastHoverKey = null;         // "no-lap"
    // モバイル用: 直近タップした点
    let lastClickedKeyMobile = null; // "no-lap"

    // --- クエリから JSON ファイル名を取得 ---
    function getJsonFileName() {
      const q = window.location.search;
      if (!q || q === "?") return "race.json";
      const name = decodeURIComponent(q.substring(1)); // 先頭の ? を除去
      return name || "race.json";
    }

    // --- ns を hh:mm:ss にフォーマット ---
    function formatDurationNsToHMS(ns) {
      if (ns == null || !isFinite(ns)) return "-";
      const totalSeconds = Math.floor(ns / 1e9); // ns → 秒（切り捨て）
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      return (
        String(hours).padStart(2, "0") + ":" +
        String(minutes).padStart(2, "0") + ":" +
        String(seconds).padStart(2, "0")
      );
    }

    // series を組み立てる（全 no 分を常に持つ）
    function buildSeries(highlightedSet) {
      if (laps.length === 0) return [];

      // モバイルは点をかなり大きめに
      const baseSymbolSize = isMobileLike ? 12 : 5;
      const highlightSymbolSize = isMobileLike ? 18 : 8;

      return nos.map(no => {
        const data = laps.map(lap => {
          const key = `${no}-${lap}`;
          const detail = noLapDetailMap.get(key);
          return detail ? detail.rank : null; // データなしは null
        });

        const isHighlight = highlightedSet.has(no);

        return {
          name: `#${no}`,
          type: "line",
          data: data,
          smooth: false,
          symbol: "circle",
          symbolSize: isHighlight ? highlightSymbolSize : baseSymbolSize,
          connectNulls: false,
          lineStyle: {
            width: isHighlight ? 3 : 1.5,
            opacity: isHighlight ? 1 : 0.3
          },
          itemStyle: {
            opacity: isHighlight ? 1 : 0.3
          },
          // ホバーで他線退色させないので emphasis は設定しない
          z: isHighlight ? 10 : 1
        };
      });
    }

    // 強調スタイルだけを更新する（legend の状態は維持）
    function updateSeriesStyle() {
      chart.setOption(
        {
          series: buildSeries(highlightedNos)
        },
        false // notMerge=false → 既存とマージ（凡例状態維持）
      );
    }

    // race JSON からグラフ用データを構築して描画
    function initRace(race, fileName) {
      const records = race.Records || [];

      if (records.length === 0) {
        statusEl.textContent = `${fileName}: Records が空です。`;
        return;
      }

      // Start.Time を取得（なければ最初のレコードの Time を代わりに使う）
      if (race.Start && typeof race.Start.Time === "number") {
        startTimeNs = race.Start.Time;
      } else {
        startTimeNs = typeof records[0].Time === "number" ? records[0].Time : null;
      }

      // Lap 一覧
      laps = Array.from(new Set(records.map(r => r.Lap))).sort((a, b) => a - b);

      // No 一覧
      nos = Array.from(new Set(records.map(r => r.No))).sort((a, b) => a - b);

      // Lap ごとに Time 昇順でソートして rank を計算
      noLapMap = new Map();
      noLapDetailMap = new Map();
      laps.forEach(lap => {
        const lapRecords = records
          .filter(r => r.Lap === lap)
          .sort((a, b) => a.Time - b.Time); // Time 昇順

        lapRecords.forEach((r, idx) => {
          const rank = idx + 1; // 1位, 2位, ...
          const key = `${r.No}-${lap}`;
          const elapsedNs =
            startTimeNs != null && typeof r.Time === "number"
              ? r.Time - startTimeNs
              : null;

          noLapMap.set(key, rank);
          noLapDetailMap.set(key, {
            rank: rank,
            lapTime: r.LapTime, // ns
            time: r.Time,       // epoch ns
            elapsed: elapsedNs  // Start からの差分 ns
          });
        });
      });

      // 最大 rank
      maxRank = 1;
      noLapMap.forEach(rank => {
        if (rank > maxRank) maxRank = rank;
      });

      // 状態リセット
      highlightedNos.clear();
      lastHoverKey = null;
      lastClickedKeyMobile = null;

      const baseOption = {
        title: {
          text: race.Name || "Race Position by Lap",
          left: "center",
          top: 0
        },
        tooltip: {
          trigger: "item",
          // モバイルは click、PC は hover+click でツールチップを出す
          triggerOn: isMobileLike ? "click" : "mousemove|click",
          formatter: params => {
            const lap = params.name;      // x 軸値 (Lap)
            const rank = params.data;     // y 値 (Rank)
            const no = String(params.seriesName || "").replace(/^#/, "");
            const key = `${no}-${lap}`;
            const detail = noLapDetailMap.get(key);

            const lapTimeRaw = detail ? detail.lapTime : null;
            const elapsedRaw = detail ? detail.elapsed : null;

            const lapTimeStr = formatDurationNsToHMS(lapTimeRaw);
            const elapsedStr = formatDurationNsToHMS(elapsedRaw);

            return (
              `no: ${no}<br/>` +
              `lap: ${lap}<br/>` +
              `rank: ${rank}<br/>` +
              `laptime: ${lapTimeStr}<br/>` +
              `time: ${elapsedStr}`
            );
          }
        },
        legend: {
          type: "scroll",
          top: 30,
          left: 0,
          right: 0
        },
        grid: {
          left: 60,
          right: 50,  // ちょっと余裕を持たせる
          top: 80,
          bottom: 50
        },
        xAxis: {
          type: "category",
          name: "Lap",
          data: laps,
          boundaryGap: false,
          nameLocation: "middle", // 軸ラベルを中央に
          nameGap: 30
        },
        yAxis: {
          type: "value",
          name: "Rank",
          min: 1,
          max: maxRank,
          inverse: true,
          interval: 1,
          axisLabel: {
            formatter: value => {
              // 一番上の 1 と、5 の倍数だけ表示
              return (value === 1 || value % 5 === 0) ? value : "";
            }
          },
          nameLocation: "middle",
          nameGap: 40
        },
        animation: false,
        series: buildSeries(highlightedNos)
      };

      chart.setOption(baseOption, true);

      // レイアウト変更後にサイズを再計算
      updateChartSize();

      // イベントハンドラは最初の一回だけ登録
      if (!handlersInitialized) {
        setupEventHandlers();
        handlersInitialized = true;
      }

      statusEl.textContent = ``;
    }

    // 凡例クリック / 点クリックのイベント
    function setupEventHandlers() {
      let ignoreLegendEvent = false;

      // PC 用: ホバーしている点を追跡
      chart.on("mouseover", params => {
        if (isMobileLike) return; // モバイルでは無視
        if (params.componentType !== "series") return;

        const no = Number(String(params.seriesName || "").replace(/^#/, ""));
        if (Number.isNaN(no)) return;

        const lap = params.name;
        lastHoverKey = `${no}-${lap}`;
      });

      chart.on("legendselectchanged", params => {
        if (ignoreLegendEvent) return;

        const legendName = params.name;  // 例: "#35"
        const no = Number(String(legendName).replace(/^#/, ""));
        if (Number.isNaN(no)) return;

        // 強調状態トグル（凡例は単純トグル）
        if (highlightedNos.has(no)) {
          highlightedNos.delete(no);
        } else {
          highlightedNos.add(no);
        }

        // ECharts が変えた legend の選択状態を元に戻す
        ignoreLegendEvent = true;
        chart.dispatchAction({
          type: "legendToggleSelect",
          name: legendName
        });
        ignoreLegendEvent = false;

        updateSeriesStyle();
      });

      // グラフ内の点/線クリック
      chart.on("click", params => {
        if (params.componentType !== "series") return;

        const no = Number(String(params.seriesName || "").replace(/^#/, ""));
        if (Number.isNaN(no)) return;

        const lap = params.name; // x 軸カテゴリ (Lap)
        const key = `${no}-${lap}`;

        if (isMobileLike) {
          // --- モバイルの挙動 ---
          if (!highlightedNos.has(no)) {
            // まだ強調されていない → 必ず強調 ON
            highlightedNos.add(no);
          } else {
            // 既に強調されている → 同じ点を連続タップしたときだけ解除
            if (lastClickedKeyMobile === key) {
              highlightedNos.delete(no);
            }
          }
          // 今回タップした点を記録
          lastClickedKeyMobile = key;
        } else {
          // --- PC の挙動 ---
          if (!highlightedNos.has(no)) {
            // まだ強調されていない → 強調 ON
            highlightedNos.add(no);
          } else {
            // 既に強調されている → 「ホバーしている点」と同じなら解除
            if (lastHoverKey === key) {
              highlightedNos.delete(no);
            }
            // ホバー位置と違う点なら強調は維持
          }
        }

        updateSeriesStyle();
      });
    }

    // JSON を読み込む
    async function loadRaceJson() {
      const jsonFile = getJsonFileName();
      try {
        const res = await fetch(jsonFile);
        if (!res.ok) {
          throw new Error("HTTP " + res.status);
        }
        const race = await res.json();
        initRace(race, jsonFile);
      } catch (err) {
        console.error(err);
        statusEl.textContent =
          `Failed to load ${jsonFile}: ` +
          err.message +
          "（file:// では動かないので http サーバ経由で開いてください）";
      }
    }

    // ページ読み込み時に JSON を読み込む
    loadRaceJson();

    // ===== ここまで JS =====
  </script>
</body>
</html>
